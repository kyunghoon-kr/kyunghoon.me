{"componentChunkName":"component---src-templates-blog-post-js","path":"/graphql/graphql-start/","result":{"data":{"site":{"siteMetadata":{"title":"Kyunghoon.me"}},"markdownRemark":{"id":"2c4afc7b-912f-58f8-8fbc-a009ddcb4e48","excerpt":"GraphQL이란 GraphQL은 페이스북에서 만든 API를 위한 쿼리 언어이다. 라고 되어있기 때문에 QL은 이해가 가지만 왜 Graph라고 붙였을까, 라고 공홈을 살펴보면 다음과 같은 문구가 있다. GraphQL…","html":"<h1 id=\"graphql이란\"><a href=\"#graphql%EC%9D%B4%EB%9E%80\" aria-label=\"graphql이란 permalink\" class=\"anchor-header\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GraphQL이란</h1>\n<p>GraphQL은 페이스북에서 만든 API를 위한 쿼리 언어이다. <code class=\"language-text\">쿼리 언어</code>라고 되어있기 때문에 QL은 이해가 가지만 왜 Graph라고 붙였을까, 라고 공홈을 살펴보면 다음과 같은 문구가 있다.</p>\n<blockquote>\n<p>GraphQL을 사용하면 비즈니스 도메인을 그래프로 모델링 할 수 있습니다.</p>\n</blockquote>\n<p>GraphQL은 스키마를 정의하고, 스키마 내에서 서로 다른 타입의 데이터가 연관, 연결되는 방식을 함께 정의할 수 있다. API에 있는 데이터를 보다 더 직관적이고 쉽게 표현할 수 있다는 것이다. GraphQL은 인터페이스만 정의하기 때문에, 어느 한 백엔드/DB에 의존하지 않고 자유롭게 사용이 가능하다.</p>\n<h2 id=\"rest-api와의-비교\"><a href=\"#rest-api%EC%99%80%EC%9D%98-%EB%B9%84%EA%B5%90\" aria-label=\"rest api와의 비교 permalink\" class=\"anchor-header\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rest API와의 비교</h2>\n<h3 id=\"하나의-endpoint\"><a href=\"#%ED%95%98%EB%82%98%EC%9D%98-endpoint\" aria-label=\"하나의 endpoint permalink\" class=\"anchor-header\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>하나의 Endpoint</h3>\n<p>많은 백엔드/프론트엔드 개발자들은 Rest API로 데이터를 주고받는 형태에 익숙할 것이다. 하지만 유지보수적 관점에서 보았을 때 서버의 덩치가 점점 커지고, 기능이 추가될 때 마다 다음과 같은 문제에 당면하게 된다.</p>\n<ul>\n<li>\n<p>1)한 기능을 위해 여러 종류의 API가 호출 된다</p>\n<ul>\n<li>모듈화가 잘 되어 있더라도 특정 기능을 위해 여러 API를 여러 Endpoint에서 호출해야 할 수 있다.</li>\n</ul>\n</li>\n<li>2)그렇지 않기 위해 Fit한 API를 만들려면 또 새롭게 개발해야 한다</li>\n<li>3)따라서 유지보수가 어렵다</li>\n</ul>\n<p>하지만 GraphQL의 가장 큰 특징 중 하나는 Endpoint가 하나라는 것이다. GraphQL은 하나의 Endpoint만 제공하며, 단 한번의 요청으로 원하는 것을 모두 가져올 수 있게끔 한다. API나 View를 따로 신경쓰며 개발할 필요가 없다.<br>\n그리고 GraphQL은 모든 스키마를 그래프처럼 연결하기 때문에 이 데이터간의 참조를 자연스럽게 받아들인다. Rest API 형태였다면 여러 서버에서 불러와 가공하거나, 타입을 매칭시켜줘야 할 수 있겠지만 GraphQL은 그렇지 않다.</p>\n<h3 id=\"fit-request\"><a href=\"#fit-request\" aria-label=\"fit request permalink\" class=\"anchor-header\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fit Request</h3>\n<p>GraphQL은 한번의 요청으로 원하는 부분만 가져오기 때문에, 불필요한 데이터까지 가져오는 <code class=\"language-text\">Overfetching</code>이 발생하지 않는다. 반대로 Rest API 형태였다면 다양한 데이터를 여러 곳에서 참조해야 하기 때문에 여러번 API를 호출하는 <code class=\"language-text\">Underfetching</code>도 발생하지 않는다. 모든 요청을 Query, Mutation 등의 형태로 정의하여 가져오기 때문이다. 클라이언트 측에서 서버가 아닌 데이터를 직접 제어하기 때문에, 항상 예측 가능한 결과를 가져올 수 있다.</p>\n<h2 id=\"-레퍼런스\"><a href=\"#-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4\" aria-label=\" 레퍼런스 permalink\" class=\"anchor-header\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📚 레퍼런스</h2>\n<p><a href=\"https://graphql-kr.github.io/\">GraphQL 공식 홈페이지</a></p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"/graphql/graphql-start/#graphql%EC%9D%B4%EB%9E%80\">GraphQL이란</a></p>\n<ul>\n<li>\n<p><a href=\"/graphql/graphql-start/#rest-api%EC%99%80%EC%9D%98-%EB%B9%84%EA%B5%90\">Rest API와의 비교</a></p>\n<ul>\n<li><a href=\"/graphql/graphql-start/#%ED%95%98%EB%82%98%EC%9D%98-endpoint\">하나의 Endpoint</a></li>\n<li><a href=\"/graphql/graphql-start/#fit-request\">Fit Request</a></li>\n</ul>\n</li>\n<li><a href=\"/graphql/graphql-start/#-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4\">📚 레퍼런스</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[GraphQL] - 1)Rest API와 비교","date":"2022-07-25","description":"GraphQL 공부를 시작하며 Rest API의 차이와에 대해 정리합니다.","tag":"graphql","thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBA//EABgBAAIDAAAAAAAAAAAAAAAAAAABAgMF/9oADAMBAAIQAxAAAAFSrtDiHLLEQGf/xAAaEAACAgMAAAAAAAAAAAAAAAABAhARABIh/9oACAEBAAEFAgpOaXCngtTBYtH/xAAWEQADAAAAAAAAAAAAAAAAAAABESD/2gAIAQMBAT8BLj//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAZEAEAAgMAAAAAAAAAAAAAAAABECEAICL/2gAIAQEABj8CrORhNLY//8QAHBABAAICAwEAAAAAAAAAAAAAAQARMVEQIUFh/9oACAEBAAE/ISVHRl1LOrGkzMRgi05D0huWj4/NxbV4OBmujj//2gAMAwEAAgADAAAAEOAPvf/EABYRAQEBAAAAAAAAAAAAAAAAAAEREP/aAAgBAwEBPxBU5Bbn/8QAFREBAQAAAAAAAAAAAAAAAAAAASD/2gAIAQIBAT8QVj//xAAfEAEAAgEDBQAAAAAAAAAAAAABABExIUFxEFFh0fD/2gAIAQEAAT8Qfa7ZpAIjTYcj1EUiUmiMtCAWfFZmVQytG7hWOZ5kVgo2NMPSmh7dP//Z","aspectRatio":1,"src":"/static/0831110fbea4d0f4ac5ff7db0313e800/5eb52/graphql-logo.jpg","srcSet":"/static/0831110fbea4d0f4ac5ff7db0313e800/9dc27/graphql-logo.jpg 300w,\n/static/0831110fbea4d0f4ac5ff7db0313e800/5eb52/graphql-logo.jpg 580w","sizes":"(max-width: 580px) 100vw, 580px"}}}}},"previous":{"fields":{"slug":"/free/코드의-성능과-가독성/"},"frontmatter":{"title":"[짧생글] 코드의 가독성과 성능에 대한 생각"}},"next":null},"pageContext":{"id":"2c4afc7b-912f-58f8-8fbc-a009ddcb4e48","previousPostId":"ea0a58e9-dca4-5f9f-85b3-4672cd1fbb0f","nextPostId":null}},"staticQueryHashes":["2841359383","916993862","985854018"]}