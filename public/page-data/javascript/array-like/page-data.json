{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/array-like/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"0c3dd61f-d7e6-5565-9475-67559bd23b44","excerpt":"Javascript에는 유사배열이(Array-Like)라는 개념이 존재한다. 이름 그대로 배열인 척 하는 객체라고 생각하면 된다. 유사배열에 대해 다루기에 앞서 Javascript의 Object…","html":"<p>Javascript에는 유사배열이(Array-Like)라는 개념이 존재한다. 이름 그대로 배열인 척 하는 객체라고 생각하면 된다.</p>\n<p>유사배열에 대해 다루기에 앞서 Javascript의 Object 개념에 대해 자세히 파헤쳐보아야 한다. 명쾌한 설명을 위해 내 경험을 공유해보겠다.</p>\n<h2>Python의 Dictionary, Java의 HashMap..</h2>\n<p>최근에 PS와 함께 알고리즘을 공부하면서 자료구조에 대해 다룰 일이 많아졌다. Iterable한 객체의 대표격인 배열만으로도 반복되는 데이터를 다룰 수 있지만, 메모리와 시간에서 극한의 효율을 끌어내야 하는 PS에서는 Key, Value를 사용하는 Dictionary 형태의 자료구조로 Iterable을 표현해야 할 때도 많다.</p>\n<p>고유한 Key를 통해 Value를 호출하는 형태의 자료구조는 Python에서는 Dictionary, Java에서는 HashMap 등이 있다. (완전히 같다고 보긴 어려울 수 있지만)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n    &#39;name&#39;:&#39;pey&#39;,\n    &#39;phone&#39;:&#39;0119993323&#39;,\n    &#39;birth&#39;: &#39;1118&#39;\n}</code></pre></div>\n<p>선언 및 사용 방식은 언어마다 다르겠지만 다음과 같은 형식을 취한다. Javascript는 Object라는 개념을 통해 Python의 Dictionary를 표현할 수 있다.</p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object\">developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object</a></p>\n<hr>\n<h2>😒 이 얘기를 왜 하는 거죠 …?</h2>\n<p>이제 흔한 유사배열의 예를 들어보겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let arrayLikeObject = {\n    0: &#39;a&#39;,\n    1: &#39;b&#39;,\n    2: &#39;c&#39;,\n    length: 3\n}</code></pre></div>\n<p>그냥 Object와 똑같아 보인다. key 값으로 숫자가 사용되었고, length라는 key가 따로 있는 것 뿐?</p>\n<p>그래서 처음에는 유사배열 = 객체, 라고 인지하였다. 유사배열이라는 단어는 알고리즘 풀이를 찾아보면서 발견한 개념이었기 때문에 그냥 객체와 혼용해서 사용하는 단어라고 생각했다.</p>\n<p>[##<em>Image|kage@c6Hasy/btq1XhUH7f8/shSPfsdIZ5hTfDbwInU8Nk/img.png|alignCenter|data-origin-width=“0” data-origin-height=“0” data-ke-mobilestyle=“widthContent”|유사배열은 MDN에서도 나오지 않았다.. 이러니 헷갈릴 수 밖에.. ㅠㅠ ||</em>##]</p>\n<p>하지만 잘 찾아보면 유사배열은 두 가지 조건을 가지고 있다.</p>\n<h4>1. Indexing이 가능하다</h4>\n<p>- 유사배열은 array[0], array[1]의 형태로 인덱싱이 가능하도록 각 요소에 0부터 시작하는 숫자 형태의 index가 있어야 한다.</p>\n<h4>2. length 프로퍼티가 있어야 한다.</h4>\n<p>- 배열에는 .length를 통해 요소의 갯수에 접근할 수 있다. 유사배열도 배열인 척 하는 녀석이기 때문에 마찬가지로 .length 프로퍼티가 존재해야 한다.</p>\n<p>모든 객체가 유사배열로 표현할 수 있는 것이 아니라, 다음과 같이 객체이면서도 배열의 특징을 어느정도 띄고 있어야 유사배열로 본 다는 것이다.</p>\n<hr>\n<h2>유사배열의 활용</h2>\n<p>유사배열을 그럼 실제로 어디서 볼 수 있나? 라는 질문을 하면 여러 포스팅에서도 다음과 같은 예제를 든다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;kr&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=&quot;container&quot;&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;/div&gt;\n    &lt;div&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;script&gt;\n    const container = document.querySelector(&#39;#container&#39;).children;\n    console.log(container);\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre></div>\n<p>다음과 같이 여러개 나열된 DOM에 선택자를 통해 접근할 때, 나온 값을 콘솔에 찍어보면 다음과 같이 나온다.</p>\n<p>[##<em>Image|kage@cR2DvP/btq101JRna4/NkFlNtiF3XKYsqKbUsKx90/img.png|alignCenter|data-origin-width=“0” data-origin-height=“0” data-ke-mobilestyle=“widthContent”|||</em>##]</p>\n<p>프로토타입이 HTMLCollection이라고 되어 있는데, 얼핏보면 배열처럼 보인다. 하지만 배열의 프로토타입 메소드인 forEach 같은 것을 사용해보면 타입에러가 발생한다.</p>\n<p>[##<em>Image|kage@lu0sj/btq1WOydwTX/CE83GeyJnkZLleBGLk3eg1/img.png|alignCenter|data-origin-width=“0” data-origin-height=“0” data-ke-mobilestyle=“widthContent”|||</em>##]</p>\n<p>결국에 배열인척하지만 근본은 객체라는 뜻이다. 유사배열을 배열처럼 사용하려면 배열로 바인딩해서 사용하거나, 배열로 변환한 후 사용해야 한다.</p>\n<h4>1. ES6을 사용하고 있다면</h4>\n<p>ES6에서는 Array.from() 메소드를 통해 배열로 변환할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let array = Array.from(arrayLike);\narray.forEach((el) =&gt; {\n\tconsole.log(el); // 문제없다\n});</code></pre></div>\n<h4>2. 그 전 버전이라면</h4>\n<p>Array.prototype.call을 통해 this로 바인딩하여 배열인 것 처럼 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Array.prototype.forEach.call(arrayLike, (value, key) =&gt; {\n    console.log(`${value} : ${key}`);\n})</code></pre></div>\n<p>PS에서는 ES6이 제공되지 않는 경우가 많기 때문에(Baekjoon같은 경우 node.js) 두 번째 방법을 주로 사용한다.</p>\n<hr>\n<h2>📚 레퍼런스</h2>\n<p><a href=\"https://kamang-it.tistory.com/entry/JavaScript15%EC%9C%A0%EC%82%AC%EB%B0%B0%EC%97%B4-%EA%B0%9D%EC%B2%B4Arraylike-Objects\">kamang-it.tistory.com/entry/JavaScript15%EC%9C%A0%EC%82%AC%EB%B0%B0%EC%97%B4-%EA%B0%9D%EC%B2%B4Arraylike-Objects</a></p>\n<p>[</p>\n<p>[JavaScript-15]유사배열 객체(Array-like Objects)</p>\n<p>본 강의는 자바스크립트의 기초를 대충 안다고 가정하고 시작하는 조금 심도 깊은 포스팅이다. 완전 처음부터 배우고 싶다면 다른 블로그나 책의 글을 참조하기를 바란다. 특별한 추가 설명이</p>\n<p>kamang-it.tistory.com</p>\n<p>](<a href=\"https://kamang-it.tistory.com/entry/JavaScript15%EC%9C%A0%EC%82%AC%EB%B0%B0%EC%97%B4-%EA%B0%9D%EC%B2%B4Arraylike-Objects\">https://kamang-it.tistory.com/entry/JavaScript15%EC%9C%A0%EC%82%AC%EB%B0%B0%EC%97%B4-%EA%B0%9D%EC%B2%B4Arraylike-Objects</a>)</p>\n<p><a href=\"https://www.zerocho.com/category/JavaScript/post/5af6f9e707d77a001bb579d2\">www.zerocho.com/category/JavaScript/post/5af6f9e707d77a001bb579d2</a></p>\n<p>[</p>\n<p>(JavaScript) 배열과 유사배열</p>\n<p>안녕하세요. 이번 시간에는 배열과 유사배열에 대해서 살펴보겠습니다. 배열은 다들 아실겁니다. 그런데 유사배열은 잘 모르는 입문자분들이 많이 계십니다. 한 번 둘의 차이를 알아봅시다. var</p>\n<p>www.zerocho.com</p>\n<p>](<a href=\"https://www.zerocho.com/category/JavaScript/post/5af6f9e707d77a001bb579d2\">https://www.zerocho.com/category/JavaScript/post/5af6f9e707d77a001bb579d2</a>)</p>","frontmatter":{"title":"유사배열 파헤치기","date":"February 12, 2021","description":"Gatsby와 Netlify를 이용한 GitHub Blog 구축","tag":"Javascript","thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/UlEQVQ4y5WR63aTQBSFeTGt1l6S2kZt9d1dmjSBXAm3CczA3GB7ZqBJY/0jrG/tfQbYc84QjB6ecDX+gneXY8/44RH3X7/j8+QJk28/cDd5xMfrMT5cjQZ6//7yBhefbnFxeUvP73A9nuBmdI8g2hVYEvN1gcWmQMFKHMoK7DCo99UrX6KsOPZphrxgyHJG3xxIc/8sEJxDawNjDBopIZUmVagJ51/q43ojYdsOHQCSo5qWPGnwvEpQNoawqGQLoQGhOnBPO+jJu3cOtTmj4BoJk9CUGuziFHFWIUlzIvXjSKX8bi1tfQYtumncJIo6rusGgqhoypRGdutBVmpkZQtGuxhjYWl0ay385VLRne6h/tcVswSsZghiOtDEHSoTKHntz8jYFpp4UWuoO9t3bG3na4cxfS2loW4VeRo5rwR1J8AbRWhPreyRhs4uUxV2TYE1/e2k4VRzFFr0GIFccf+ObA0CN6bvhPSE8Sg3PnWxsTv8EjP8zJaYHlZYyR3iLvXsPZn3ddcgUHTIb7EDFKgp0OwRyhU2FLQeWDVEvcVWJ0jaHHGboelkH+i6OoUMGPMqMMaMh1iwNZ5ZhBkL8Tubkw+xFBvsKcx1eRb4N28CRYR5scacLTErQkzzhVe3QcQ32NIU/xU4pQ6nGQUUESmF5SEFRj3kV83WB/4BEy7EfacGH9AAAAAASUVORK5CYII=","aspectRatio":1.5957446808510638,"src":"/static/e2c0701953d8e0fe21e1da0cb7dd321f/f3583/test-commit.png","srcSet":"/static/e2c0701953d8e0fe21e1da0cb7dd321f/630fb/test-commit.png 300w,\n/static/e2c0701953d8e0fe21e1da0cb7dd321f/2a4de/test-commit.png 600w,\n/static/e2c0701953d8e0fe21e1da0cb7dd321f/f3583/test-commit.png 1200w,\n/static/e2c0701953d8e0fe21e1da0cb7dd321f/bbee5/test-commit.png 1800w,\n/static/e2c0701953d8e0fe21e1da0cb7dd321f/0ef64/test-commit.png 2400w,\n/static/e2c0701953d8e0fe21e1da0cb7dd321f/96d01/test-commit.png 2880w","sizes":"(max-width: 1200px) 100vw, 1200px"}}}}},"previous":null,"next":{"fields":{"slug":"/github-blog/"},"frontmatter":{"title":"Gatsby와 Netlify를 이용한 GitHub Blog 구축"}}},"pageContext":{"id":"0c3dd61f-d7e6-5565-9475-67559bd23b44","previousPostId":null,"nextPostId":"d384be66-5de0-56fb-b6dc-63aa510ea652"}},"staticQueryHashes":["2841359383","916993862","985854018"]}